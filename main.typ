#set text(font: "Noto Serif JP", fallback: false, lang: "ja", region: "JP")
#set page(numbering: "1 / 1")
#set heading(numbering: "1.")
#let numbering_with_header = n => numbering("1.1", counter(heading).get().first(), n)
#set figure(numbering: numbering_with_header)
#set math.equation(numbering: n => "(" + numbering_with_header(n) + ")")

#let definition = figure.with(
  kind: "definition",
  supplement: [定義],
)

#let theorem = figure.with(
  kind: "theorem",
  supplement: [定理],
)

#let proof = body => {
  strong[証明]
  parbreak()
  body
  align(right, sym.square)
}

#show figure.where(kind: "definition").or(figure.where(kind: "theorem")): it => align(
  left,
  rect(width: 100%, stroke: gray, inset: (y: 1em), {
    terms.item(
      {
        it.supplement
        counter(figure.where(kind: it.kind)).display(it.numbering)
      },
      if it.caption != none {
        it.caption.body
      },
    )

    it.body
  }),
)

#show heading.where(level: 1): it => {
  counter(figure.where(kind: "definition")).update(0)
  counter(figure.where(kind: "theorem")).update(0)
  counter(math.equation).update(0)
  it
}

#align(center, text(size: 2em)[
  圏論についての個人的ノート
])

#align(center, rect(width: 100%, inset: (y: 1em), {
  strong[注意]

  align(left)[
    このノートはあくまで個人的なものであり、その正確性については保証しない。
    また、独自の記法も使用するので、よく注意すること。
  ]
}))

#outline()

= 圏

== 群 <ba9d86c3c1d845e18ab46f2f3617bfbc>

加法における$0$と乗法における$1$が似ているというのは、皆が一度は思うであろう簡単な事実である。

$ 0 + x = x = x + 0 $ <7e638d1108ba4b858122cf1c22f36145>
$ 1 times x = x = x times 1 $ <625a5052e3ca49cd9f7a383ea4c9fa7f>

#ref(<7e638d1108ba4b858122cf1c22f36145>)と#ref(<625a5052e3ca49cd9f7a383ea4c9fa7f>)の形から分かるように、$0$を加えることと$1$を乗じることは「無意味」という点で似ているのである。
さらに考察を続ければ、ある観点ではこれらの演算は「同一視」出来ると言えることも分かる。

$ exp(x + y) = (exp x) times (exp y) $ <d8a58e0e52914890a102b0fa388ab468>
$ log(x times y) = (log x) + (log y) $ <5bc372eaf25347479ef811cbc8b360ed>
$ log(exp x) = x = exp(log x) $ <5c19b462ef17421296386e529831eee7>

#ref(<d8a58e0e52914890a102b0fa388ab468>)により加法を乗法に「変換」することが、#ref(<5bc372eaf25347479ef811cbc8b360ed>)により乗法を加法に「変換」することができ、#ref(<5c19b462ef17421296386e529831eee7>)がそれら「変換」の正当性を保証している。
「変換」の正当性とはつまり、二つの演算を互いに「変換」しても結果は変わらないということである。
$exp$と$log$という2つの関数を使うことで加法の世界と乗法の世界を自由に行き来でき、それによって加法と乗法は「同一視」できるのである。

この主張は群という代数的構造によってより数学的に述べることが出来る。

#definition(caption: [群])[
  群とは、集合$G$と$G$上の二項演算$f : G^2 -> G$の組$(G, f)$であって、次の条件を満たすものである。

  + 単位元$e in G$が存在して、任意の元$g in G$に対して、$f(e, g) = g = f(g, e)$が成り立つ。
  + 任意の元$g in G$に対して、逆元$g^(- 1) in G$が存在して、$f(g, g^(- 1)) = e = f(g^(- 1), g)$が成り立つ。
  + 任意の元$g, h, i in G$に対して、結合法則$f(f(g, h), i) = f(g, f(h, i))$が成り立つ。
] <a1e4cb7e37d24b4a995b9477a8ac072d>

#ref(<a1e4cb7e37d24b4a995b9477a8ac072d>)の$G$と$f$を置き換えれば、$(RR, +)$と$(RR_(> 0), times)$が群であることはほぼ自明である。
ここで重要なのは、#ref(<7e638d1108ba4b858122cf1c22f36145>)および#ref(<625a5052e3ca49cd9f7a383ea4c9fa7f>)より、$0$と$1$がそれぞれの群の単位元なっていることである。
これが、演算において「無意味」という点で似ていることの正体である。
「変換」について論じるには、準同型写像を用いれば良い。
ただし、群$(G, f)$を単に台集合$G$で表し、演算$f(g, h)$は$g$と$h$を単に繋げて$g h$と書くことにする。

#definition(caption: [群準同型写像])[
  写像$f: G -> H$が群$G$から群$H$への準同型写像であるとは、任意の元$g_1, g_2 in G$に対して$f(g_1 g_2) = f(g_1) f(g_2)$が成り立つことである。
]

「変換」とは正に準同型写像のことであり、#ref(<d8a58e0e52914890a102b0fa388ab468>)は$exp: RR -> RR_(> 0)$が、#ref(<5bc372eaf25347479ef811cbc8b360ed>)は$log: RR_(> 0) -> RR$が準同型写像であることを示す式である。
準同型写像$f: G -> H$が存在すれば、その写像を用いて$H$上での演算を$G$上で再現できる可能性がある。
何故なら、$h_1, h_2 in H$に対して$f(g_1) = h_1, f(g_2) = h_2$となる$g_1, g_2 in G$を見つけることが出来れば、$h_1 h_2 = f(g_1 g_2)$となるからである。
問題はそのような$g_1, g_2$が存在しない可能性があることなので、そのための条件を加えた写像を考える。

#definition(caption: [群同型写像])[
  写像$f: G -> H$が群$G$から群$H$への同型写像であるとは、準同型写像かつ全単射であることである。
]

#ref(<5c19b462ef17421296386e529831eee7>)からも分かるように、$exp, log$は互いを逆写像とする全単射なので、同型写像である。
一般に、写像$f: G -> H$が全単射であれば逆写像$f^(- 1): H -> G$が存在するので、常に$f(g) = h$となるような$g = f^(- 1)(h)$を見つけることができる。
よって、$H$上の演算は常に$G$上で再現可能である。
また、さらに$f^(- 1)$も同型写像となるのである。

#theorem[
  $f: G -> H$が同型写像ならば、$f^(- 1): H -> G$も同型写像である。
] <00de405b71504d66926a672d810db246>

#proof[
  任意の元$h_1, h_2 in H$に対して、$g_1 = f^(- 1)(h_1), g_2 = f^(- 1)(h_2)$とすれば

  $ f^(- 1)(h_1 h_2) = f^(- 1)(f(g_1) f(g_2)) = f^(- 1)(f(g_1 g_2)) = g_1 g_2 = f^(- 1)(h_1) f^(- 1)(h_2) $

  が成り立つので、$f^(- 1)$は$H$から$G$への準同型写像である。
  全単射であることは自明なので、$f^(- 1)$は同型写像である。
]

#ref(<00de405b71504d66926a672d810db246>)により、$G$上の演算もまた$H$上で再現可能であることが分かる。
さらに、$f$と$f^(- 1)$は互いを逆写像とする全単射なので、「変換」による情報のロスは発生しない。
これの意味するところは、もはや$G$での演算と$H$での演算は同じものであり、どちらを用いるかは好みの問題だということである。

#definition(caption: [群同型])[
  群$G$と群$H$が同型であるとは、$G$から$H$への同型写像が存在することであり、$G tilde.eq H$と表す。
]

同型写像$exp, log$の下で$(RR, +) tilde.eq (RR_(> 0), times)$であり、この意味で加法と乗法は「同一視」出来るのである。

== 代数的構造

#ref(<ba9d86c3c1d845e18ab46f2f3617bfbc>)では群と呼ばれる代数的構造の一種についての簡単な議論をした。
このような、定義のもとの抽象的な構造のことを一般に代数的構造と言う。
群も代数的構造の一種である。
このような代数的構造を考える明確な意味は、具体的な構成を隠して抽象的な構造のみを証明に用いることによる、証明の再利用である。
言い換えるならば、インターフェースとしての役割がある。
例えば、#ref(<00de405b71504d66926a672d810db246>)は$RR, RR_(> 0), +, times, exp, log$の何れの具体的構成も用いずに証明されている。
よって、これは任意の群$G, H$に適用できる定理となっている。
定理を使用する側が必要なことは、ある集合と演算が#ref(<a1e4cb7e37d24b4a995b9477a8ac072d>)を満たしていることを証明するだけである。
また、構造に明確な定義ができるということは、準同型写像のように構造を比較するものも定義することができることを意味する。
これは、$(RR, +)$と$(RR_(> 0), times)$がどれだけ似ているかを議論する上での便利なツールであることは疑いようも無い。
実際、代数的構造の有用性は広く知られており、群の他にも環、体、ベクトル空間のような、様々な構造が研究対象となっている。

しかし、ここで、ある単純な問が生まれる。
それは、代数的構造全体も、また何らかの構造を有しているのではないかという直感である。
#ref(<a1e4cb7e37d24b4a995b9477a8ac072d>)を満たすような群は当然$(RR, +)$や$(RR_(> 0), times)$だけではなく無数にあり、それらは準同型写像によって複雑なネットワークを成しているのではないだろうか。
思い返せば、そのような構造は他にもある。
例えば、集合と写像、ベクトル空間と線形写像、ある集合上の二項関係など。
もしこれらに共通する代数的構造を定義できたなら、それは非常に有用だと予想される。
何故なら、集合論や群論、線形代数論に共通の言語を与えるだけでなく、その間の準同型が代数的構造全体の成す代数的構造の関係を露にするからだ。
集合論には具体的構成によって理論の無矛盾性を保証する役割があるように、抽象代数学の共通のインターフェースとしての役割を見出せるだろう。
そして、それこそが圏論なのである。

== 圏

様々な構造を一般化する定義として様々な方法が考えられるが、圏論では「矢印」を用いる。
その直感的な意味を考えるならば「ものからものへの関係」と言えるが、代数的構造によくあるように常にそうである訳ではない。
よって、初めて定義に触れるのであれば、グラフ理論における向き付きグラフのようなものを想像すれば取り合えずは十分である。

#definition(caption: [圏])[
  圏$C$とは、以下の条件を満たすものである。

  + 対象の類$C$が存在する。
  + 任意の対象$a, b in C$に対して、$a$から$b$への射の類$C(a, b)$が存在する。
  + 任意の対象$a in C$に対して、恒等射$1_a in C(a, a)$が存在する。
  + 任意の対象$a, b, c in C$と射$f in C(a, b), g in C(b, c)$に対して、$f$と$g$の合成射$f dot.op g in C(a, c)$が存在する。
  + 任意の対象$a, b in C$と射$f in C(a, b)$に対して、$1_a dot.op f = f = f dot.op 1_b$が成り立つ。
  + 任意の対象$a, b, c, d in C$と射$f in C(a, b), g in C(b, c), h in C(c, d)$に対して、$(f dot.op g) dot.op h = f dot.op (g dot.op h)$が成り立つ。
]

ただし、圏の定義には様々な流派があり、用いる記号の違いが少なくない。
例えば

- 対象の類は明示的に$abs(C)$や$"Ob"(C)$と書く。
- $a$から$b$への射の類は$"Hom"(a, b)$や$"Hom"_(C)(a, b)$と書く。
- $a$の恒等射は$"id"_a$と書く。

などである。
しかし、これらは些細な違いであり、特に気にする必要はない。
それよりも重要なことは、射の合成の順番である。
というのも、一般に$f in C(a, b), g in C(b, c)$の射の合成は$g compose f in C(a, c)$と左から$g, f$の順番で書くのが一般的である。
だが、これが個人的に混乱する書き方なので、このノートでは$f, g$の順番を採用する。
この順番で書くことを図式順記法と言うのだが、広く用いられている記号は無いようである。
おそらく最も一般的なのが$f; g$という記法だが、やはり$g compose f$に比べればマイナーだと思われる。
ともかく、$g compose f$以外の記法を用いる際は注意すること。
繰り返すが、このノートでは$f dot g$の記法を用いる。
