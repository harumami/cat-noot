#set text(font: "Noto Serif JP", fallback: false, lang: "ja", region: "JP")
#set page(numbering: "1 / 1")
#set heading(numbering: "1.")
#let numbering_with_header = n => numbering("1.1", counter(heading).get().first(), n)
#set figure(numbering: numbering_with_header)
#set math.equation(numbering: n => "(" + numbering_with_header(n) + ")")

#let definition = figure.with(
  kind: "definition",
  supplement: [定義],
)

#let theorem = figure.with(
  kind: "theorem",
  supplement: [定理],
)

#let proof = body => {
  strong[証明]
  parbreak()
  body
  align(right, sym.square)
}

#show figure.where(kind: "definition").or(figure.where(kind: "theorem")): it => align(
  left,
  rect(width: 100%, stroke: gray, inset: (y: 1em), {
    terms.item(
      {
        it.supplement
        counter(figure.where(kind: it.kind)).display(it.numbering)
      },
      if it.caption != none {
        it.caption.body
      },
    )

    it.body
  }),
)

#show heading.where(level: 1): it => {
  counter(figure.where(kind: "definition")).update(0)
  counter(figure.where(kind: "theorem")).update(0)
  counter(math.equation).update(0)
  it
}

#align(center, text(size: 2em)[
  圏論についての個人的ノート
])

#align(center, rect(width: 100%, inset: (y: 1em), {
  strong[注意]

  align(left)[
    このノートはあくまで個人的なものであり、その正確性については保証しない。
    また、独自の記法も使用するので、よく注意すること。
  ]
}))

#outline()

= 圏

== 群 <ba9d86c3c1d845e18ab46f2f3617bfbc>

加法における$0$と乗法における$1$が似ているというのは、皆が一度は思うであろう簡単な事実である。

$ 0 + x = x = x + 0 $ <7e638d1108ba4b858122cf1c22f36145>
$ 1 times x = x = x times 1 $ <625a5052e3ca49cd9f7a383ea4c9fa7f>

#ref(<7e638d1108ba4b858122cf1c22f36145>)と#ref(<625a5052e3ca49cd9f7a383ea4c9fa7f>)の形から分かるように、$0$を加えることと$1$を乗じることは「無意味」という点で似ているのである。
さらに考察を続ければ、ある観点ではこれらの演算は「同一視」出来ると言えることも分かる。

$ exp(x + y) = (exp x) times (exp y) $ <d8a58e0e52914890a102b0fa388ab468>
$ log(x times y) = (log x) + (log y) $ <5bc372eaf25347479ef811cbc8b360ed>
$ log(exp x) = x = exp(log x) $ <5c19b462ef17421296386e529831eee7>

#ref(<d8a58e0e52914890a102b0fa388ab468>)により加法を乗法に「変換」することが、#ref(<5bc372eaf25347479ef811cbc8b360ed>)により乗法を加法に「変換」することができ、#ref(<5c19b462ef17421296386e529831eee7>)がそれら「変換」の正当性を保証している。
「変換」の正当性とはつまり、二つの演算を互いに「変換」しても結果は変わらないということである。
$exp$と$log$という2つの関数を使うことで加法の世界と乗法の世界を自由に行き来でき、それによって加法と乗法は「同一視」できるのである。

この主張は群というものによってより数学的に述べることが出来る。

#definition(caption: [群])[
  群とは、集合$G$と$G$上の二項演算$f : G^2 -> G$の組$(G, f)$であって、次の条件を満たすものである。

  + 単位元$e in G$が存在して、任意の元$g in G$に対して、$f(e, g) = g = f(g, e)$が成り立つ。
  + 任意の元$g in G$に対して、逆元$g^(- 1) in G$が存在して、$f(g, g^(- 1)) = e = f(g^(- 1), g)$が成り立つ。
  + 任意の元$g, h, i in G$に対して、結合法則$f(f(g, h), i) = f(g, f(h, i))$が成り立つ。
] <a1e4cb7e37d24b4a995b9477a8ac072d>

#ref(<a1e4cb7e37d24b4a995b9477a8ac072d>)の$G$と$f$を置き換えれば、$(RR, +)$と$(RR_(> 0), times)$が群であることはほぼ自明である。
ここで重要なのは、#ref(<7e638d1108ba4b858122cf1c22f36145>)および#ref(<625a5052e3ca49cd9f7a383ea4c9fa7f>)より、$0$と$1$がそれぞれの群の単位元なっていることである。
これが、演算において「無意味」という点で似ていることの正体である。
「変換」について論じるには、準同型写像を用いれば良い。
ただし、群$(G, f)$を単に台集合$G$で表し、演算$f(g, h)$は$g$と$h$を単に繋げて$g h$と書くことにする。

#definition(caption: [群準同型写像])[
  写像$f: G -> H$が群$G$から群$H$への準同型写像であるとは、任意の元$g_1, g_2 in G$に対して$f(g_1 g_2) = f(g_1) f(g_2)$が成り立つことである。
]

「変換」とは正に準同型写像のことであり、#ref(<d8a58e0e52914890a102b0fa388ab468>)は$exp: RR -> RR_(> 0)$が、#ref(<5bc372eaf25347479ef811cbc8b360ed>)は$log: RR_(> 0) -> RR$が準同型写像であることを示す式である。
準同型写像$f: G -> H$が存在すれば、その写像を用いて$H$上での演算を$G$上で再現できる可能性がある。
何故なら、$h_1, h_2 in H$に対して$f(g_1) = h_1, f(g_2) = h_2$となる$g_1, g_2 in G$を見つけることが出来れば、$h_1 h_2 = f(g_1 g_2)$となるからである。
問題はそのような$g_1, g_2$が存在しない可能性があることなので、そのための条件を加えた写像を考える。

#definition(caption: [群同型写像])[
  写像$f: G -> H$が群$G$から群$H$への同型写像であるとは、準同型写像かつ全単射であることである。
]

#ref(<5c19b462ef17421296386e529831eee7>)からも分かるように、$exp, log$は互いを逆写像とする全単射なので、同型写像である。
一般に、写像$f: G -> H$が全単射であれば逆写像$f^(- 1): H -> G$が存在するので、常に$f(g) = h$となるような$g = f^(- 1)(h)$を見つけることができる。
よって、$H$上の演算は常に$G$上で再現可能である。
また、さらに$f^(- 1)$も同型写像となるのである。

#theorem[
  $f: G -> H$が同型写像ならば、$f^(- 1): H -> G$も同型写像である。
] <00de405b71504d66926a672d810db246>

#proof[
  任意の元$h_1, h_2 in H$に対して、$g_1 = f^(- 1)(h_1), g_2 = f^(- 1)(h_2)$とすれば

  $ f^(- 1)(h_1 h_2) = f^(- 1)(f(g_1) f(g_2)) = f^(- 1)(f(g_1 g_2)) = g_1 g_2 = f^(- 1)(h_1) f^(- 1)(h_2) $

  が成り立つので、$f^(- 1)$は$H$から$G$への準同型写像である。
  全単射であることは自明なので、$f^(- 1)$は同型写像である。
]

#ref(<00de405b71504d66926a672d810db246>)により、$G$上の演算もまた$H$上で再現可能であることが分かる。
さらに、$f$と$f^(- 1)$は互いを逆写像とする全単射なので、「変換」による情報のロスは発生しない。
これの意味するところは、もはや$G$での演算と$H$での演算は同じものであり、どちらを用いるかは好みの問題だということである。

#definition(caption: [群同型])[
  群$G$と群$H$が同型であるとは、$G$から$H$への同型写像が存在することであり、$G tilde.eq H$と表す。
]

同型写像$exp, log$の下で$(RR, +) tilde.eq (RR_(> 0), times)$であり、この意味で加法と乗法は「同一視」出来るのである。

== 代数的構造

#ref(<ba9d86c3c1d845e18ab46f2f3617bfbc>)では群についての簡単な議論をした。
群のような、ある定義によって定まる抽象的な構造のことを一般に代数的構造と言う。
代数的構造を考える明確な意味は、具体的な構成を隠して抽象的な構造のみを証明に用いることによる、証明の再利用である。
例えば、#ref(<00de405b71504d66926a672d810db246>)は$RR, RR_(> 0), +, times, exp, log$の何れの具体的構成も用いずに証明されている。
よって、これは任意の群$G, H$に適用できる定理となっている。
定理を使用する側が必要なことは、ある集合と演算が#ref(<a1e4cb7e37d24b4a995b9477a8ac072d>)を満たしていることを証明するだけである。
また、構造に明確な定義があるということは、準同型写像のような構造間の関係も定義することができることを意味する。
これが$(RR, +)$と$(RR_(> 0), times)$がどれだけ似ているかを議論する便利なツールであったことは疑いようも無い。
代数的構造の有用性は広く知られており、群の他にも環、体、ベクトル空間のような、様々な構造が研究対象となっている。

しかし、ここで、ある単純な問が生まれる。
それは、代数的構造全体も、また何らかの構造を有しているのではないかという直感である。
#ref(<a1e4cb7e37d24b4a995b9477a8ac072d>)を満たすような群は当然$(RR, +)$や$(RR_(> 0), times)$以外にも無数にあり、それらは準同型写像によって複雑なネットワークを成しているだろう。
思い返せば、集合と写像、ベクトル空間と線形写像、ある集合上の二項関係なども同じような構造として見ることができる。
もしこれらに共通する代数的構造を定義できたなら、それは非常に有用だろう。
何故なら、集合論や群論、線形代数論に共通の言語を与えるだけでなく、その間の準同型が異なる学問の関係を露にするからだ。
具体的構成によって理論の無矛盾性を保証する役割が集合論にあるように、抽象代数学の共通のインターフェースとしての役割を見出せるだろう。
そして、それこそが圏論なのである。

== 圏

様々な構造を一般化する定義として、圏論では「矢印」を用いる。
その直感的な意味を考えるならば「ものとものの関係」と言えるが、常にそうである訳ではない。
よって、初めて定義に触れるのであれば、グラフ理論における向き付きグラフのようなものだと思えば十分である。

#definition(caption: [圏])[
  圏$C$とは、以下の条件を満たすものである。

  + 対象の類$C$が存在する。
  + 任意の対象$a, b in C$に対して、$a$から$b$への射の類$C(a, b)$が存在する。
  + 任意の対象$a in C$に対して、恒等射$1_a in C(a, a)$が存在する。
  + 任意の対象$a, b, c in C$と射$f in C(a, b), g in C(b, c)$に対して、$f$と$g$の合成射$f dot.op g in C(a, c)$が存在する。
  + 任意の対象$a, b in C$と射$f in C(a, b)$に対して、$1_a dot.op f = f = f dot.op 1_b$が成り立つ。
  + 任意の対象$a, b, c, d in C$と射$f in C(a, b), g in C(b, c), h in C(c, d)$に対して、$(f dot.op g) dot.op h = f dot.op (g dot.op h)$が成り立つ。
] <c1795453f0e04184b9fdbf6fdfd53cc8>

ただし、圏の定義には様々な流派があり、用いる記号の違いが少なくない。
例えば

- 対象の類は明示的に$abs(C)$や$"Ob"(C)$と書く。
- $a$から$b$への射の類は$"Hom"(a, b)$や$"Hom"_(C)(a, b)$と書く。
- $a$の恒等射は$"id"_a$と書く。

などである。
しかし、これらは些細な違いであり、特に気にする必要はない。
それよりも重要なのは、射の合成の順番についてである。
一般的には、射$f in C(a, b), g in C(b, c)$の合成は$g compose f in C(a, c)$と左から$g, f$の順番で書く。
だが、これが個人的に混乱するので、このノートでは$f, g$の順番を採用する。
この順番で書くことを図式順記法と言うのだが、広く用いられている記号は無いようである。
おそらく最も一般的なのが$f; g$という記法だが、やはり$g compose f$に比べれば少数派だと思われる。
ともかく、$g compose f$以外の記法を用いる際は注意すること。
繰り返すが、このノートでは$f dot g$の記法を用いる。

#ref(<c1795453f0e04184b9fdbf6fdfd53cc8>)に登場するもの以外でよく用いられる記号も定義しておこう。

#definition(caption: [射の類])[
  圏$C$の射の類を$"Mor"(C)$と記す。
]

#definition(caption: [域と予域])[
  圏$C$の射$f in "Mor"(C)$に対して$f in C(a, b)$を満たすような$a, b in C$をそれぞれ域、予域と言い、$"dom"(f) = a, "cod"(f) = b$で表す。
] <fd6c44cc7606498aa3297da25435bb6e>

#ref(<fd6c44cc7606498aa3297da25435bb6e>)が成立するためには域と予域が一意に定まらなくてはならないが、これは問題にはならない。
何故なら、任意の射$f in "Mor"(C)$はある1組の対象$a, b in C$に対してのみ$f in C(a, b)$となるように圏$C$を定義すべきであり、仮にそうなっていなかったとしても、射を域や予域との組として取り直すことで直ちに回復できるからである。
このような例には#ref(<6a578525efa943219d6c53d204d4e2d2>)の集合の圏$"Set"$がある。

また、略記として、ある$a, b in C$に対して$f in C(a, b)$であることを$f: a -> b$、$f dot g$を単に繋げて$f g$とすることもある。

== 圏の大きさ

#ref(<c1795453f0e04184b9fdbf6fdfd53cc8>)からも分かる通り、対象の類$C$や射の類$C(a, b)$が集合であることは必須ではない。
しかし、それらが集合でなくてはならない場面もあるため、そのための用語を定義しておく。

#definition(caption: [圏の大きさ])[
  圏$C$が小さいとは対象の類$C$と射の類$"Mor"(C)$が共に集合であることを言う。
  一方、$C$が小さくないことを大きいと言う。
  また、$C$の小さい大きいに関わらず、任意の対象$a, b in C$に対して$a$から$b$への射の類$C(a, b)$が集合であることを局所的に小さいと言う。
]

例えば、#ref(<6a578525efa943219d6c53d204d4e2d2>)で見るような集合の圏$"Set"$などは明らかに大きな圏である。
類を誤って集合として扱うことはラッセルのパラドックスの原因となってしまうため、慎重に議論すべきである。
しかし、このノートは個人的かつ入門用なので、集合と類の区別について細かく議論はしない。
また、同様の理由から背理法や選択公理なども断りなく使用する。
さらに、$"Set"$も含めた一般的な圏は局所的に小さいので、特に説明が無い場合は局所的に小さい圏のみに限定して考えることとする。

= 集合の圏 <6a578525efa943219d6c53d204d4e2d2>
